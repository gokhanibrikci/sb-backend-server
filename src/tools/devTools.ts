import { McpServer } from "@modelcontextprotocol/sdk/server/mcp.js";
import { z } from "zod";
import { exec } from "child_process";
import { promisify } from "util";
import fs from "fs/promises";
import path from "path";

const execAsync = promisify(exec);

export function registerDevTools(server: McpServer) {
    // Git Status Tool
    server.tool(
        "sb_backend_dev_git_status",
        "Get the status of the current git repository",
        {
            repoPath: z.string().describe("Absolute path to the git repository"),
        },
        async ({ repoPath }) => {
            try {
                const { stdout } = await execAsync("git status", { cwd: repoPath });
                return {
                    content: [{ type: "text", text: stdout }],
                };
            } catch (error: any) {
                return {
                    content: [{ type: "text", text: `Error executing git status: ${error.message}` }],
                    isError: true,
                };
            }
        }
    );



    // Scaffold Project Tool
    server.tool(
        "sb_backend_dev_scaffold_project",
        "Scaffold a new project with basic structure",
        {
            projectName: z.string().describe("Name of the new project"),
            targetDir: z.string().describe("Directory to create the project in"),
        },
        async ({ projectName, targetDir }) => {
            const projectPath = path.join(targetDir, projectName);
            try {
                await fs.mkdir(projectPath, { recursive: true });
                await fs.writeFile(
                    path.join(projectPath, "README.md"),
                    `# ${projectName}\n\nGenerated by Team MCP Server.`
                );
                await fs.mkdir(path.join(projectPath, "src"));
                await fs.writeFile(
                    path.join(projectPath, "src/index.ts"),
                    `console.log("Hello from ${projectName}");`
                );

                return {
                    content: [
                        {
                            type: "text",
                            text: `Successfully scaffolded project '${projectName}' at ${projectPath}`,
                        },
                    ],
                };
            } catch (error: any) {
                return {
                    content: [{ type: "text", text: `Error scaffolding project: ${error.message}` }],
                    isError: true,
                };
            }
        }
    );


    // Git Create Branch Tool
    server.tool(
        "sb_backend_dev_git_create_branch",
        "Create a new branch and switch to it.",
        {
            repoPath: z.string().describe("Absolute path to the git repository"),
            branchName: z.string().describe("Name of the new branch"),
            baseBranch: z.string().optional().describe("Base branch (default: current HEAD)"),
        },
        async ({ repoPath, branchName, baseBranch }) => {
            try {
                // If baseBranch is provided, checkout that first, pulling latest
                if (baseBranch) {
                    await execAsync(`git checkout ${baseBranch}`, { cwd: repoPath });
                    await execAsync(`git pull`, { cwd: repoPath });
                }
                const { stdout } = await execAsync(`git checkout -b ${branchName}`, { cwd: repoPath });
                return {
                    content: [{ type: "text", text: `Created and switched to branch '${branchName}'\n${stdout}` }],
                };
            } catch (error: any) {
                return {
                    content: [{ type: "text", text: `Error creating branch: ${error.message}` }],
                    isError: true,
                };
            }
        }
    );

    // Git Commit Tool
    server.tool(
        "sb_backend_dev_git_commit",
        "Stage all changes and verify commit.",
        {
            repoPath: z.string().describe("Absolute path to the git repository"),
            message: z.string().describe("Commit message"),
        },
        async ({ repoPath, message }) => {
            try {
                await execAsync(`git add .`, { cwd: repoPath });
                const { stdout } = await execAsync(`git commit -m "${message.replace(/"/g, '\\"')}"`, { cwd: repoPath });
                return {
                    content: [{ type: "text", text: stdout }],
                };
            } catch (error: any) {
                return {
                    content: [{ type: "text", text: `Error committing: ${error.message}` }],
                    isError: true,
                };
            }
        }
    );

    // Git Push Tool
    server.tool(
        "sb_backend_dev_git_push",
        "Push commits to remote repository.",
        {
            repoPath: z.string().describe("Absolute path to the git repository"),
            remote: z.string().default("origin").describe("Remote name (default: origin)"),
            branch: z.string().describe("Branch to push"),
        },
        async ({ repoPath, remote = "origin", branch }) => {
            try {
                const { stdout, stderr } = await execAsync(`git push -u ${remote} ${branch}`, { cwd: repoPath });
                return {
                    content: [{ type: "text", text: stdout || stderr }],
                };
            } catch (error: any) {
                return {
                    content: [{ type: "text", text: `Error pushing: ${error.message}` }],
                    isError: true,
                };
            }
        }
    );

    // Git Log
    server.tool(
        "sb_backend_git_log",
        "Show commit logs.",
        {
            repoPath: z.string().describe("Absolute path to the git repository"),
            maxCount: z.number().optional().default(10).describe("Max commits to show"),
        },
        async ({ repoPath, maxCount }) => {
            try {
                const { stdout } = await execAsync(`git log -n ${maxCount} --pretty=format:"%h - %an, %ar : %s"`, { cwd: repoPath });
                return {
                    content: [{ type: "text", text: stdout }],
                };
            } catch (error: any) {
                return {
                    content: [{ type: "text", text: `Error getting log: ${error.message}` }],
                    isError: true,
                };
            }
        }
    );

    // Git Diff
    server.tool(
        "sb_backend_git_diff",
        "Show changes between commits, commit and working tree, etc.",
        {
            repoPath: z.string().describe("Absolute path to the git repository"),
            target: z.string().optional().describe("Target to diff against (default: HEAD)"),
        },
        async ({ repoPath, target }) => {
            try {
                const cmd = target ? `git diff ${target}` : `git diff`;
                const { stdout } = await execAsync(cmd, { cwd: repoPath });
                return {
                    content: [{ type: "text", text: stdout || "No changes." }],
                };
            } catch (error: any) {
                return {
                    content: [{ type: "text", text: `Error getting diff: ${error.message}` }],
                    isError: true,
                };
            }
        }
    );

    // Git Show
    server.tool(
        "sb_backend_git_show",
        "Show various types of objects (commits, tags, etc).",
        {
            repoPath: z.string().describe("Absolute path to the git repository"),
            object: z.string().describe("Object to show (e.g. commit hash)"),
        },
        async ({ repoPath, object }) => {
            try {
                const { stdout } = await execAsync(`git show ${object}`, { cwd: repoPath });
                return {
                    content: [{ type: "text", text: stdout }],
                };
            } catch (error: any) {
                return {
                    content: [{ type: "text", text: `Error showing object: ${error.message}` }],
                    isError: true,
                };
            }
        }
    );

    // Git Blame
    server.tool(
        "sb_backend_git_blame",
        "Show what revision and author last modified each line of a file.",
        {
            repoPath: z.string().describe("Absolute path to the git repository"),
            file: z.string().describe("File to blame"),
        },
        async ({ repoPath, file }) => {
            try {
                const { stdout } = await execAsync(`git blame "${file}"`, { cwd: repoPath });
                return {
                    content: [{ type: "text", text: stdout }],
                };
            } catch (error: any) {
                return {
                    content: [{ type: "text", text: `Error blaming file: ${error.message}` }],
                    isError: true,
                };
            }
        }
    );
}
